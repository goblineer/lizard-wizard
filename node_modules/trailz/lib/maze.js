/**
 * Creates an instance of a Maze structure.  A maze is created within an
 * M x N grid of cells.  This grid is then given to a processing Algorithm
 * to carve out passages within the grid.
 *
 * #### Examples:
 *
 * ```javascript
 * import {AlgorithmType, Maze} from 'trailz';
 * const maze = new Maze(10, 10, AlgorithmType.BinaryTree);
 * console.log(maze.string);
 * ```
 *
 * @module Maze
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sprintf_js_1 = require("sprintf-js");
const util_constants_1 = require("util.constants");
const algorithm_1 = require("./algorithm");
const grid_1 = require("./grid");
class Maze {
    constructor(rows, cols, algorithm = algorithm_1.AlgorithmType.RecursiveBacktracker) {
        this._algorithms = {
            [algorithm_1.AlgorithmType.AldousBroder]: new algorithm_1.AldousBroder(),
            [algorithm_1.AlgorithmType.BinaryTree]: new algorithm_1.BinaryTree(),
            [algorithm_1.AlgorithmType.HuntAndKill]: new algorithm_1.HuntAndKill(),
            [algorithm_1.AlgorithmType.RecursiveBacktracker]: new algorithm_1.RecursiveBacktracker(),
            [algorithm_1.AlgorithmType.Sidewinder]: new algorithm_1.Sidewinder(),
            [algorithm_1.AlgorithmType.Wilsons]: new algorithm_1.Wilsons()
        };
        if (rows < 1)
            rows = 1;
        if (cols < 1)
            cols = 1;
        this.resize(rows, cols, algorithm);
        console.log(`Finished creating maze with ${this.algorithm}`);
    }
    /**
     * @return {string} the algorithm currently set within this instance.
     */
    get algorithm() {
        return this._algorithm;
    }
    /**
     * @return {number} the number of columns in this maze
     */
    get cols() {
        return this._grid.cols;
    }
    /**
     * @return {Grid} returns a reference to the grid within the Maze instance
     */
    get grid() {
        return this._grid;
    }
    /**
     * @return {number[][]} a 2D array that represents how each cell is drawn
     */
    get repr() {
        return this._grid.repr;
    }
    /**
     * @return {number} the number of rows in this maze
     */
    get rows() {
        return this._grid.rows;
    }
    /**
     * @return {string} a string representation of the 2D repr array
     */
    get srepr() {
        let line;
        const repr = this._grid.repr;
        const out = [];
        for (let row = 0; row < this.rows; row++) {
            line = [];
            for (let col = 0; col < this.cols; col++) {
                line.push(sprintf_js_1.sprintf("%3d", repr[row][col]));
            }
            out.push(line.join(","));
        }
        return out.join(util_constants_1.nl);
    }
    /**
     * @return {string} an ASCII string representation of the maze
     */
    get string() {
        return this._grid.toString();
    }
    /**
     * Takes a given maze algorithm, resets the gride and applies this algorithm to the
     * grid.  The previous grid is lost with this operation.
     * @param algorithm {AlgorithmType} the algorithm that will be applied to the grid.
     * this is an enumeration with the possible types that can be generated.
     */
    rebuild(algorithm) {
        this._algorithm = algorithm;
        this._grid.reset();
        this._algorithms[algorithm].process(this._grid);
    }
    /**
     * Allows one to change the initial size of the grid.  This will created the grid and
     * apply the given algorithm to the newly sized grid.
     * @param rows {number} the new number of rows in this grid
     * @param cols {number} the new number of cols in this grid
     * @param [algorithm] {AlgorithmType} the maze algorithm that will be applied to the
     * grid.  If one is not given, then the initial algorithm is reapplied.
     */
    resize(rows, cols, algorithm = this.algorithm) {
        this._grid = new grid_1.Grid(rows, cols);
        this.rebuild(algorithm);
    }
}
exports.Maze = Maze;
//# sourceMappingURL=maze.js.map