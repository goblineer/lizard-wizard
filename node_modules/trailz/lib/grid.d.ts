import { Cell } from "./cell";
/**
 * This class represents an array of cells by row and column
 */
export declare class Grid {
    private _cols;
    private _debug;
    private _flat;
    private _grid;
    private _repr;
    private _rows;
    constructor(rows: number, cols: number, debug?: boolean);
    /**
     * @return {number} the total number of columns in the grid container
     */
    readonly cols: number;
    /**
     * @return {Cell[]} a list of cells that are dead ends within the grid
     */
    readonly deadends: Cell[];
    /**
     * @return {Cell[]} an array copy of all cells in the grid as a 1D array.
     */
    readonly flatten: Cell[];
    /**
     * @return {Cell} a random cell location from the grid
     */
    readonly random: Cell;
    /**
     * @return {number[][]} a byte representation of the current maze.
     */
    readonly repr: number[][];
    /**
     * @return {number} the total number of rows in the grid
     */
    readonly rows: number;
    /**
     * @return {number} the total size of the grid container
     */
    readonly size: number;
    /**
     * Retrieves a cell at the requested location.  If the location is outside
     * of the grid, then null is returned.
     * @param row {number} the row in the grid
     * @param col {number} the column in the grid
     * @returns {Cell} the cell within the grid location.  If outside the range
     * then null.
     */
    at(row: number, col: number): Cell;
    /**
     * Resets the internal state of the grid so that the algorithm can be
     * reapplied.
     */
    reset(): void;
    toString(): string;
    [Symbol.iterator](): IterableIterator<Cell>;
}
