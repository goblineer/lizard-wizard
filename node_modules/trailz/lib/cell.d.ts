/**
 * A single cell reference that is used within a grid.
 *
 * @module Cell
 */
/**
 * A class that represents a single grid cell.
 */
export declare class Cell {
    private _links;
    private _col;
    private _row;
    private _north;
    private _south;
    private _east;
    private _west;
    constructor(row: number, col: number);
    /**
     * @return {number} the column position for this cell within a grid
     */
    readonly col: number;
    /**
     * @return {Cell[]} the list of cells linked to this one
     */
    readonly links: Cell[];
    /**
     * @return {boolean} true if there are links from this cell, otherwise false
     */
    readonly linksEmpty: boolean;
    /**
     * @return {Cell[]} the list of valid neighbors for this cell
     */
    readonly neighbors: Cell[];
    /**
     * Each side of a cell (square) in the maze is either *on* or *off* when
     * carving into the maze.  This function will take the values of each
     * side and compute a number that represents how the side will be drawn.
     *
     * e.g.
     *                                   +---+
     * 15 (decimal) => 1111 (binary) =>  |   |
     *                                   +---+
     *
     *                                   +---+
     * 11 (decimal) => 1011 (binary) =>  |
     *                                   +---+
     *
     * The bit pattern is made up of "top, right, bottom, left" (TRBL).  In
     * the first example above, 15 shows that top = 1, right = 1, bottom = 1
     * and left = 1, for a bit pattern of 1111 and a number 15.
     *
     * The second patterns shows top = 1, right = 0, bottom = 1, and left = 1
     * for a bit pattern of 1011 and a number 11.
     *
     * Each of the patterns represent the 16 possible patterns for a square.
     *
     * @return {number} a byte representation of the cell for drawing.
     */
    readonly repr: number;
    /**
     * @return {number} the row position of this cell within the grid
     */
    readonly row: number;
    /**
     * @return {Cell[]} the list of valid neighbors that have been visited
     */
    readonly visitedNeighbors: Cell[];
    /**
     * @return {Cell[]} the list of valid neighbors that have not been used
     */
    readonly unvisitedNeighbors: Cell[];
    north: Cell;
    south: Cell;
    east: Cell;
    west: Cell;
    /**
     * Carves a path (links) this cell to the given cell.  This opens the path
     * between the two cells.
     * @param cell {Cell} the cell to link to from this cell
     * @param bidi {boolean} determines if the link is bidirectional.  If this
     * is true, then the link is made from the cell back to this one.  It is
     * on by default.
     * @return {Cell} a reference to self
     */
    link(cell: Cell, bidi?: boolean): Cell;
    /**
     * Determines if the given cell is linked to this one.
     * @param cell {Cell} the input cell to check against this cell
     * @return {boolean} true if the given cell is linked to this one, otherwise
     * false.
     */
    linked(cell: Cell): boolean;
    /**
     * Clears all links and resets the neighbors
     */
    reset(): void;
    toString(): string;
    /**
     * Removes the linkage between this cell and the given input cell.
     * @param cell {Cell} the cell to link to from this cell
     * @param bidi {boolean} determines if the link is bidirectional.  If this
     * is true, then the link is made from the cell back to this one.  It is
     * on by default.
     * @return {Cell} a reference to self
     */
    unlink(cell: Cell, bidi?: boolean): Cell;
}
