import { EventEmitter } from 'events';

/**
 * A comparator function signature.  This is used to perform a comparison
 * operation between two objects.
 */
export declare type Comparator<T> = (o1: T, o2: T) => number;
export declare enum Color {
	red = 0,
	black = 1
}
export declare type Id = string | number;
export declare type AugmentedNode<T> = Node<T> & T;
export interface NodeKeys {
	id?: Id;
	parentId?: Id;
}
export interface NodeReferences<T> {
	children?: Array<AugmentedNode<T>>;
	parent?: Node<T>;
}
export interface NodeData<T> {
	data?: T;
}
export interface NodeOptions<T> extends NodeKeys, NodeReferences<T>, NodeData<T> {
	color?: Color;
	left?: Node<T>;
	right?: Node<T>;
}
/**
 * The data nodes used within a collection.  This generally would not be
 * used outside of these collection classes.
 */
export declare class Node<T> implements NodeOptions<T> {
	private _options?;
	id?: Id;
	parentId?: Id;
	children?: Array<AugmentedNode<T>>;
	parent?: Node<T>;
	data?: T;
	color?: Color;
	left?: Node<T>;
	right?: Node<T>;
	constructor(_options?: NodeOptions<T>);
	clear?(): void;
	toString(): string;
}
/**
 * An interface shared by any object that can insert or remove data.
 * @interface
 */
export interface Iterable<T> {
	find(data: T | Id): T | Node<T>;
	insert(data: T | Node<T>): void;
	remove(data: T | Node<T>): void;
}
export declare abstract class Collection<T> extends EventEmitter {
	protected _comparator: Comparator<T>;
	protected _first: any;
	protected _last: any;
	protected _length: number;
	protected _nil: Node<T>;
	protected _root: any;
	/**
	 * Base class constructor for all collection classes.
	 * @param comparator {Function} a comparator function used for searching within
	 * the container.
	 * @constructor
	 */
	constructor(comparator?: Comparator<T>);
	/**
	 * @return {T} the last (max) data element from the tree.
	 */
	readonly back: T;
	/**
	 * @return {boolean} return true if the list has no nodes, otherwise false
	 */
	readonly empty: boolean;
	readonly end: T;
	/**
	 * @returns {T} the first (min) data element from the tree.
	 */
	readonly first: T;
	/**
	 * @returns {T} the front (min) data element from the tree.
	 */
	readonly front: T;
	/**
	 * @return {T} the last (max) data element from the tree.
	 */
	readonly last: T;
	/**
	 * @return {number} the number of nodes in this collection
	 */
	readonly length: number;
	/**
	 * @return {Node<T>} the reference to the nil sentinel
	 */
	readonly nil: Node<T>;
	/**
	 * @return {Node<T>} the front/first node in the collection
	 */
	readonly root: Node<T>;
	/**
	 * @return {number} the number of nodes in this collection
	 */
	readonly size: number;
	/**
	 * Initializes the object to an empty state
	 */
	clear(): void;
	/**
	 * Checks the container for the existence of a given object.  This is
	 * a simple linear search.
	 * @param obj {Object} the item to find in the container.
	 * @returns {boolean} true if the item is found, otherwise false.
	 */
	contains(obj: T): boolean;
	/**
	 * Checks if the container is empty.
	 * @returns {boolean} true if the container is empty, otherwise false.
	 */
	isEmpty(): boolean;
}
/**
 * The abstract base class for all Tree data structures
 *
 */
export declare abstract class Tree<T> extends Collection<T> {
	protected _height: number;
	protected _x: Node<T>;
	constructor(comparator?: Comparator<T>);
	/**
	 * Initializes the object to an emtpy state.  This can be used to
	 * quickly empty the tree and start over.
	 */
	clear(): void;
}
/**
 * Implements a binary tree structure using a Red/Black tree algorithm.
 *
 */
export declare class BinaryTree<T> extends Tree<T> implements Iterable<T> {
	constructor(arr?: T[], comparator?: Comparator<T>);
	/**
	 * Performs a breadth first traversal of the tree and saves it to an array
	 * of T type (of the tree).  The array of data is returned.  Don't use this
	 * with a large tree.
	 * @returns {T[]} an array of all elements in the tree in breadth order
	 */
	readonly breadth: T[];
	/**
	 * @return {number} computes and returns the height of the tree.
	 */
	readonly height: number;
	/**
	 * @return {T[]} the results of an inorder traversal of the tree.  The
	 * results are stored in an array and returned.
	 */
	readonly inorder: T[];
	/**
	 * @return {T[]} the results of a postorder traversal of the tree.  The
	 * results are stored in an array and returned.
	 */
	readonly postorder: T[];
	/**
	 * @return {T[]} the results of a preorder traversal of the tree.  The
	 * results are stored in an array and returned.
	 */
	readonly preorder: T[];
	/**
	 * Peforms a breadth first search against the tree.  Generally this is not
	 * the best way to search the tree (use contains to determine if a key is
	 * in it).
	 * @param data {T} the data element to search for (based on the data type
	 * of the tree)
	 * @param node {T} the starting node for the search.  This is root by
	 * default
	 * @return {boolean} true if the item is found in the tree, otherwise
	 * false is returned.
	 */
	breadthSearch(data: T, node?: Node<T>): boolean;
	/**
	 * Performs a typically binary search through the tree.
	 * @param data {T} the data element to search for (based on the data type
	 * of the tree)
	 * @return {boolean} true if the item is found in the tree, otherwise
	 * false is returned.
	 */
	contains(data: T): boolean;
	/**
	 * Searches the tree for an element.  If it is found, then the data element
	 * associated with that node is returned (not the node).  When used with a
	 * primative type this is not useful as the key and the value found would
	 * be the same.  This is helpful when T is a complex object with a custom
	 * Comparator.
	 * @param key {T} a search key to look for in the tree.
	 * @return {T} the full data element within this tree.  If it is not found,
	 * then null is returned.
	 */
	find(key: T): T;
	/**
	 * Internal method that traverses the tree to compute the current height.
	 * This is used by the `.height` property
	 * @param node {Node<T>} the starting node position to start the height
	 * count.
	 * @private
	 */
	private findHeight;
	private inorderDelegate;
	/**
	 * Inserts a data element into the tree.
	 * @param data {T} the data element to insert into the tree
	 */
	insert(data: T): void;
	private insertDelegate;
	private insertFixUp;
	private newNode;
	private postorderDelegate;
	private preorderDelegate;
	/**
	 * Removes the given data value from the tree.
	 * @param data {T} the data value to remove
	 */
	remove(data: T): T;
	/**
	 * Special case function to quickly find and remove the first item in the
	 * tree.
	 * @return {T} the data element that was first and removed from the tree.
	 */
	removeFirst(): T;
	private removeFixUp;
	/**
	 * Special case function to quickly find and remove the last item in the
	 * tree.
	 * @return {T} the data element that was last and removed from the tree.
	 */
	removeLast(): T;
	/**
	 * Replaces one subtree as a child of its parent with another subtree
	 * @param u {Node<T>} parent subtree
	 * @param v {Node<T>} child subtree to use in replacement
	 * @private
	 */
	private transplant;
	/**
	 * Searches the tree for a specific node within the tree.
	 * @param data {T} the data value to search for in the tree.
	 * @return {Node<T>} if the data is found, then the node that holds it is
	 * returned.  If it is not found, then nil is returned.
	 */
	_findNode(data: T): Node<T>;
	/**
	 * Localized left rotation of nodes.  This is a public function but is private
	 * by convention (for testing).  Generally not called as part of the api.
	 */
	_leftRotate(x: Node<T>): void;
	/**
	 * Searches a tree from a given node for the maximum value in that
	 * (sub)tree.  Note that the property `.largest` can be used to
	 * quickly retrieve the largest value in the tree.  This is really used
	 * to recompute the maximum value when it is removed from the tree.
	 * @param node {Node<T>} the node location to start the search.  By
	 * default this is the root node if no node is given.
	 * @return {Node<T>} the largest node in the (sub)tree.
	 */
	_maximum(node?: Node<T>): Node<T>;
	/**
	 * From a node, searches a tree or subtree for the minimum value in that
	 * (sub)tree.  Note that the property `.smallest` can be used to
	 * quickly retrieve the smallest value in the tree.  This is really used
	 * to recompute the minimum value when it is removed from the tree.
	 * @param node {Node<T>} the node location to start the search.  By
	 * default this is the root node if no node is given.
	 * @return {Node<T>} the smallest node in the (sub)tree.
	 */
	_minimum(node?: Node<T>): Node<T>;
	/**
	 * Localized right rotation of nodes.  This is a public function but is private
	 * by convention (for testing).  Generally not called as part of the api.
	 */
	_rightRotate(x: Node<T>): void;
	/**
	 * The successor of a node is the node with the smallest key greater than
	 * node.data.
	 * @param node {Node<T>} the node location to start the search for a
	 * successor.
	 * @return {Node<T>} a reference to the successor node.
	 */
	_successor(node: Node<T>): Node<T>;
	/**
	 * Implements an inorder successor algorithm to process each node through
	 * an iterator.
	 */
	[Symbol.iterator](): IterableIterator<T>;
}
/**
 * A doubly linked list structure.
 *
 */
export declare class List<T> extends Collection<T> implements Iterable<T> {
	static readonly FRONT: number;
	static readonly BACK: number;
	constructor(arr?: T[], comparator?: Comparator<T>);
	/**
	 * @return {T[]} an inorder array of all elements in the list
	 */
	readonly array: T[];
	/**
	 * @return {T[]} a reversed array of all elements in the list
	 */
	readonly reverse: T[];
	/**
	 * Retrieves the data from the list at a given position.  If the position
	 * is outside of the list, then null is returned.  This is an O(N)
	 * operation for each call (it looks for each position from the start
	 * of th list).
	 * @param pos {number} the position to retrieve from the list
	 * @return {T} the data associated with this position within the list
	 */
	at(pos: number): T;
	/**
	 * Searches the list for an element.  If it is found, then the data element
	 * associated with that node is returned (not the node).  When used with a
	 * primative type this is not useful as the key and the value found would
	 * be the same.  This is helpful when T is a complex object with a custom
	 * Comparator.
	 * @param key {T} a search key to look for in the list.
	 * @return {T} the full data element within this list.  If it is not found,
	 * then null is returned.
	 */
	find(key: T): T;
	/**
	 * Inserts a data value into a linked list.  The default operation is to
	 * insert into the end of the list.
	 * @param data {T} the data item to insert into the list
	 * @param idx {number} the index position where the item will be inserted.
	 * this number be List.FRONT, List.BACK, or any other number.
	 */
	insert(data: T, idx?: number): void;
	/**
	 * Removes an element from the list.
	 * @param data {T} the data item removed from the list
	 * @param [idx] {number} the position index to remove from the list
	 * @return {T} the data element that was deleted
	 */
	remove(data: T, idx?: number): T;
	/**
	 * Iterates through the list and find the node associated with a key
	 * value T.
	 * @param data {T} the key value or index to search for in the list.
	 * @return {Node<T>} a reference to the node that was found.  If a node
	 * is not found, then null is returned.
	 */
	_getNodeByValue(data: T): Node<T>;
	/**
	 * Moves to a position within the list and finds the node associated
	 * with that index.
	 * @param idx {number} the location within the list to find
	 * @return {Node<T>} a reference to a node a the given position.  If the
	 * node is not found, then null is returned.
	 */
	_getNodeByIndex(idx: number): Node<T>;
	/**
	 * An inorder iterator through the list of current values.
	 */
	[Symbol.iterator](): IterableIterator<T>;
}
/** Simple FIFO queue implementation */
export declare class Queue<T> extends List<T> {
	protected _end: Node<T>;
	constructor(arr?: T[], comparator?: Comparator<T>);
	/**
	 * Removes and returns the item at the front of the queue.
	 * @returns {T} the data at the front of the queue.
	 */
	dequeue(): T;
	/**
	 * Removes all items from the queue in order and returns them as an
	 * array of data values.
	 * @returns {Array} a list of queue items as an array.
	 */
	drain(): T[];
	/**
	 * Searches the queue for the requested data element and removes it
	 * from the queue.
	 * @param data {Object} the data element that should be removed from
	 * the queue.
	 */
	eject(data: T): T;
	/**
	 * Adds an item to the end of the queue.
	 * @param data {Object} the data to insert into the queue.
	 */
	enqueue(data: T): void;
	/**
	 * Override wrapper for the push function from the inherited stack.  A
	 * stack always pushes to the front.  The general queue should always push
	 * to the end of the structure.
	 * @param data {Object} the data to push on the end of the queue.
	 */
	push: (data: T) => void;
}
/** A double ended Queue class */
export declare class Deque<T> extends Queue<T> {
	private _maxSize;
	/**
	 * The deque can be unlimited in size (default) or set to a maxium size
	 * when constructed.  When the max size is exceeded, then the front item is
	 * automatically removed from the queue and the new item is placed in the
	 * queue (depending on  which type of insert is calld).
	 * @param maxSize=0 {number} - The maximum size for this queue.
	 * @param arr=[] {T[]} - An array of initial input values
	 * @param comparator {Function} - a comparator function used for searching within
	 * the container.
	 * @constructor
	 */
	constructor(maxSize?: number, arr?: T[], comparator?: Comparator<T>);
	/**
	 * Checks the current internals for an overflow condition.  This occurs
	 * when the maxSize storage size will be exceeded on the next insert
	 * operation.
	 * @returns {boolean} true if in an overflow condition, otherwise false.
	 */
	readonly overflow: boolean;
	/**
	 * Adds an item to the end of the queue.  Checks for an overflow condition
	 * and acts if one is detected.
	 * @param data {Object} the data item to add to the queue.
	 */
	enqueue(data: T): void;
	/**
	 * Inserts a data element to the front of the queue.  Checks for an
	 * overflow condition and acts if one is detected.
	 * @param data {Object} the data item to add to the queue.
	 */
	pushFront(data: T): void;
	/**
	 * Adds an item to the end of the queue.  Checks for an overflow condition
	 * and acts if one is detected.
	 * @param data {Object} the data item to add to the queue.
	 */
	pushBack(data: T): void;
	/**
	 * Returns the first item from the queue and removes it.
	 * @returns {Object} the data value on the front of the queue.
	 */
	popFront(): T;
	/**
	 * Retrieves the last item from the queue and removes it.
	 * @returns {Object} the data value on the back of the queue.
	 */
	popBack(): T;
}
export interface TreeIndex<T> {
	[key: string]: TreeNode<T>;
}
export declare type TreeNode<T> = AugmentedNode<T>;
export declare type GeneralTreeItem<T> = TreeNode<T>;
export declare type GeneralTreeFlat<T> = NodeKeys & NodeData<T> & T;
export declare type ToStringCallback<T> = (val: TreeNode<T>) => string;
export declare type WalkCallback<T> = (val: TreeNode<T>) => void;
export interface GeneralTreeOptions<T> {
	sequence?: number;
	testing?: boolean;
	treeData?: Array<TreeNode<T>>;
	useindex?: boolean;
	usesanitize?: boolean;
}
/**
 * Implements a general tree structure
 */
export declare class GeneralTree<T> extends Tree<T> implements Iterable<T> {
	private _dirty;
	private _options;
	private _sequence;
	private _treeIndex;
	constructor(options?: GeneralTreeOptions<T>, comparator?: Comparator<T>);
	/**
	 * @return {boolean} true if the tree has been changed before the last walk operation
	 */
	readonly dirty: boolean;
	/**
	 * @return {TreeNode<T>} a reference to the first item in the tree and null if empty.
	 */
	readonly first: TreeNode<T>;
	/**
	 * @return {number} the depth of the tree
	 */
	readonly height: number;
	/**
	 * @return {TreeNode<T>} a reference to the last item in the tree and null if empty.
	 */
	readonly last: TreeNode<T>;
	/**
	 * @return {boolean} returns true if the module is under test, otherwise false
	 */
	readonly testing: boolean;
	/**
	 * @return {Array<TreeNode<T>>} a reference to the current tree array structure
	 */
	/**
	* Sets the internal representation of the tree structure array to a new array.
	* Generally this should not be used, but this is exposed for use in another
	* 3rd party library to allow it access to change the struccture (react treeview)
	* @param val {Array<TreeNode<T>>} the new array of nodes to make as the new tree
	*/
	treeData: Array<TreeNode<T>>;
	/**
	 * @return {TreeIndex<T>} a reference to the that holdes the id/node index relationship
	 */
	readonly treeIndex: TreeIndex<T>;
	/**
	 * @return {boolean} if true, then the index is being used by the tree
	 */
	readonly useindex: boolean;
	/**
	 * @return {boolean} if true, then nodes within the tree will be sanitized when the
	 * walk routine is used.  This will ensure that all key fields are present within a
	 * node.  This is important when the .treeData function can opverride the current
	 * array.  The sanitize is used to ensure tree integrity.
	 */
	readonly usesanitize: boolean;
	/**
	 * Convenience method for adding a node to the index.
	 * @param node {TreeNode<T>} - a reference to the node to insert into the index
	 */
	private addToIndex;
	/**
	 * Resets the tree.  This will clear out the current tree arrayu and all
	 * reference pointers to first/last and the current index.
	 */
	clear(): void;
	/**
	 * Searches through all of the nodes to see if they contain the given
	 * search field data.  This works like findByField.  This function
	 * wraps that method and checks if it returned anyting.
	 * @return {boolean} true if the dat fields are found within the
	 * tree, otherwise false.
	 */
	contains(dataToFind: T): boolean;
	/**
	 * Creates a new node object with the given node properties as
	 * a parameter.  The given properties are merged into the newly
	 * created node.
	 * @param node {GeneralTreeItem} - the node fields to assign to the new
	 * node object
	 * @return {GeneralTreeItem} a new node instance reference
	 */
	createNode(configNode?: GeneralTreeItem<T>): GeneralTreeItem<Node<T>>;
	/**
	 * Takes a 1D array, created by the flatten function, and expands it into
	 * the tree.  The current tree is replaced by this expanded tree.
	 * @param flatNodes {Array<GeneralFlatTree<T>>} - the array of flattened
	 * nodes that will be used to expand the tree.
	 */
	expand(flatNodes: Array<GeneralTreeFlat<T>>): void;
	/**
	 * Performs a breadth search of the tree for a matching id value.  If
	 * the item has been seen before, then it is retrieved from an index (if
	 * useindex is set to true).
	 * @param searchId {Id} the id value to search for in the tree
	 * @return {GeneralTreeItem} of the item found otherwise null
	 */
	find(searchId: Id): TreeNode<T>;
	/**
	 * Searches every node in the tree for data matching the given search critera
	 * in the dataToFind parameter.  The comparator defined when the class
	 * is instantiated is used to compare the dataToFind against each node in the
	 * tree.  Every node that is found is placed into an array and that
	 * array is returned to the caller.
	 * @param dataToFind {T} - the input data matching the template fields for
	 * the tree.
	 * @returns {GeneralTreeItem[]} an array of tree nodes that match
	 * the search criteria.  If no nodes are found, then an empty array is
	 * returned.
	 */
	findByField(dataToFind: T): Array<TreeNode<T>>;
	/**
	 * Retrieves the list of nodes associated with the given parent key.
	 * This is basically get all of the children associated with the
	 * given parent ID value.
	 * @param parentId {Id} - the parent id key value field to search
	 * for.
	 * @return {GeneralTreeItem[]} - all of the children associated with
	 * the given parent.  If there are no children, then an empty array
	 * is returned.
	 */
	findByParent(parentId: Id): AugmentedNode<T>[];
	/**
	 * Walks through the tree data and flattens it into a 1D array of nodes.
	 * This flatten can be reversed using the expand function.
	 * @return {Array<GeneralTreeFlat<T>>} an array of nodes representing the
	 * tree and its parent/child key relationship.
	 */
	flatten(): Array<GeneralTreeFlat<T>>;
	/**
	 * Generates a new unique key for a node.  When the testing flag is set
	 * to true, then the id is an ordered sequence.  This is done to make
	 * the keys predictable when the code is under test.
	 * @return {Id} the new key value.
	 */
	private getNewKey;
	/**
	 * Takes a child array and and id and searches the array for the existence
	 * of that id within it.
	 * @param searchId {Id} - the id value to use in the search
	 * @param children {Array<TreeNode<T>>} - child array to search for an id
	 * @return {boolean} true if the id was found in the array, otherise false.
	 */
	private isIdInChildren;
	/**
	 * Searches the current child list for an id and returns the index location
	 * within the child list where it is at.  If it is not found, then the
	 * index is -1.
	 * @param searchId {Id} - the id value to use in the search
	 * @param children {Array<TreeNode<T>>} - child array to search for an id
	 * @reutrn {number} the index location of the child within the array. A
	 * -1 is returned if not found.
	 */
	private indexInChildren;
	/**
	 * Inserts a new node into the general tree.
	 * @param dataToInsert {TreeNode<T>} - the config information for the node
	 * that will be inserted (note that this is NOT the node inserted).  Generally
	 * the parentId is used to determine where it will be inserted.
	 * @param asFirstChild=true {boolean} - determines what end of the child
	 * array will be used when adding the new node to the tree.  If true, then
	 * the new node is inserted at the beginning of the array, otherise at the
	 * end.  The default behavior is the front.
	 * @param validate=false {boolean} - if true, then validate .id values
	 * on the input config data to ensure no duplidates.
	 * @return {GeneralTreeItem<Node<T>>} a reference to the new node that was
	 * inserted into the tree.  On error this is null (with a corresponding
	 * warning message).
	 */
	insert(dataToInsert: TreeNode<T>, asFirstChild?: boolean, validate?: boolean): GeneralTreeItem<Node<T>>;
	/**
	 * Removes a node from the tree.  If the node is a parent with
	 * children, then the `deleteWithChildren` flag can be used to
	 * stop the delete process if children are present.  This is allowed
	 * by default (so deleting a parent deletes its children).  When this
	 * flag is true, then the delete would not be allowed until all of the
	 * children are deleted first.  The delete operations are expensive
	 * because a re-walk of the tree is required to fix indexing and
	 * first/last pointers.
	 * @param idToRemove {Id} - the id value of the node to remove
	 * @param deleteWithChildren=false {boolean} - if true, then a parent
	 * with children cannot be deleted until all children are removed.
	 */
	remove(idToRemove: Id, deleteWithChildren?: boolean): void;
	private removeFromIndex;
	/**
	 * Takes an input node and ensures that it has all key fields.	 It
	 * also creates the node key value if one does not exist.
	 * @param node {TreeNode<T>} the node to fix
	 * @return {TreeNode<T>} a referece back of the node that was sanitized
	 */
	private sanitize;
	/**
	 * Iterates through all of the nodes and concatenates them into a string.
	 * Only prints the relevant key information from the tree.  This also
	 * takes a callback function sent by the user to deal with the template
	 * data that may be part of the tree nodes.  The internals of the tree
	 * can't know the T value(s) while running.  This callback will
	 * receive a reference to the node being printed.  The caller can then
	 * use this to print the T values it passed into the tree.
	 * @param dynamicDataTCallback {ToStringCallback<T>} - a function that can
	 * process the tempate data T and return a string representation of it.
	 * @return {string} the string representing the keys and T data in the
	 * general tree.
	 */
	toString(dynamicDataTCallback?: ToStringCallback<T>): string;
	/**
	 * Performs an inorder traversal of the current tree.  At each node
	 * a callback function is executed and the node being processed
	 * is given as a parameter.
	 * @param fn {WalkCallback<T>} a callback function invoked on each
	 * node as it is encountered.
	 */
	walk(fn: WalkCallback<T>): void;
	/**
	 * An inorder iterator through the nodes of the general tree.
	 */
	[Symbol.iterator](): IterableIterator<AugmentedNode<T>>;
}
export interface Priority<T> {
	priority: string;
	data?: T;
}
/**
 * A simple priority queue.  Items are inserted into a queue structure with an
 * associatd priority number.  The lower the number, the higher the priority.
 * Items with a higher priority are chosen first in the queue.
 *
 * Priority values are numbers > 0.  If a negative number is given, then it
 * will be given a priority of 0.
 *
 * The implementation is a Red/Black tree.  That makes getting the lowest
 * value from a set of values an O(1) operation; we always know the smallest
 * value inserted into the tree.
 *
 */
export declare class PriorityQueue<T> extends BinaryTree<Priority<T>> {
	private _offsets;
	constructor();
	/**
	 * @return {T[]} an array of values in the queue in priority order.  This
	 * does not change the queue.
	 */
	readonly array: T[];
	/**
	 * Clears the queue and resets the internals.
	 */
	clear(): void;
	/**
	 * Retrieves the highest priority item from the queue and returns it.
	 * @return {T} the data with the highest priority.  If no data is available
	 * then null is returned;
	 */
	dequeue(): T;
	/**
	 * Removes all items from the queue in order and returns them as an
	 * array of data values.
	 * @returns {T[]} a list of queue items as an array.
	 */
	drain(): T[];
	/**
	 * Adds an item to the queue in priority order.  Items of the same priority
	 * are sorted by insertion order.  The lower number represents higher
	 * priority.
	 * @param data {T} the data element to add to the queue
	 * @param priority {number} a number >= 0 that sets the priority of the
	 * item in the queue.
	 */
	enqueue(data: T, priority: number): void;
}
/**
 * A linked list structure that sorts the data in ascending order as it is
 * added.
 *
 */
export declare class SortedList<T> extends List<T> {
	constructor(arr?: T[], comparator?: Comparator<T>);
	/**
	 * Inserts a data value into a linked list in its insertion sorted
	 * position.  The sort is in ascending order.  The `.reverse` property
	 * can be used to get the opposite sort (returned array)
	 * @param data {T} the data item to insert into the list
	 */
	insert(data: T): void;
}
/** Simple stack class */
export declare class Stack<T> extends Collection<T> {
	constructor(comparator?: Comparator<T>);
	/**
	 * A convenience method for calling top.
	 * @returns {Object} the data element at the top of the stack
	 */
	peek(): T;
	/**
	 * Puts a data element on the top of the stack
	 * @param data {Object} any data element the user wants to store
	 */
	push(data: T): void;
	/**
	 * Retrieves the top item from the stack and returns it.
	 * @returns {Object} the data element at the top of the stack.
	 */
	pop(): T;
	/**
	 * Retrieves the data element at the top of the stack without removing
	 * it.  This clones the object so that changes will not affect what is
	 * actually on the top of the stack.
	 * @returns {Object} a reference to the data element at the top of the
	 * stack.
	 */
	top(): T;
}